package org.broadinstitute.monster.etl.clinvar.models.output

import io.circe.Encoder
import io.circe.derivation.{deriveEncoder, renaming}
import upack.Msg

/**
  * Reference information stored by ClinVar about a variation,
  * generated by expert review of aggregate submissions.
  *
  * @param id ClinVar accession for the reference info
  * @param version version of the reference containing the remaining fields
  * @param variationId unique ID for the variation referred to by
  *                    the info
  * @param vcvId unique ID for the variation archive which captures
  *              the reference info
  * @param title title for the reference
  * @param dateLastEvaluated day when the reference info was last
  *                          reviewed by an expert panel
  * @param reviewStatus description of the info's current state in
  *                     the review process
  * @param interpretation clinical significance of the variation described
  *                       by the reference info, as decided by the expert panel
  * @param submissionCount number of submissions to ClinVar which were
  *                        aggregated to form this reference
  * @param independentObservations number of independent observations
  *                                submitted to ClinVar which were
  *                                aggregated to form this reference
  */
case class RCV(
  id: String,
  version: Long,
  variationId: String,
  vcvId: String,
  title: Option[String],
  dateLastEvaluated: Option[String],
  reviewStatus: Option[String],
  interpretation: Option[String],
  submissionCount: Option[Long],
  independentObservations: Option[Long],
  traitSetId: Option[String]
)

object RCV {
  import org.broadinstitute.monster.etl.clinvar.MsgOps

  implicit val encoder: Encoder[RCV] = deriveEncoder(renaming.snakeCase, None)

  /** Parse a raw RCVAccesion payload into our expected model. */
  def fromRawAccession(
    variation: Variation,
    vcv: VCV,
    traitSets: Array[VCVTraitSet],
    traits: Array[VCVTrait],
    rawRcvAccession: Msg
  ): RCV = {
    val relevantTraitIds = rawRcvAccession
      .extractList("InterpretedConditionList", "InterpretedCondition")
      .flatMap { rawCondition =>
        val conditionDb = rawCondition.extract("@DB").map(_.str)
        val conditionId = rawCondition.extract("@ID").map(_.str)
        val conditionValue = rawCondition.value.str

        if (conditionDb.contains("MedGen")) {
          traits.find(_.medgenId == conditionId)
        } else {
          traits.find(_.name.contains(conditionValue))
        }
      }
      .map(_.id)
      .toSet

    val relevantTraitSetId =
      traitSets.find(_.traitIds.toSet == relevantTraitIds).map(_.id)

    RCV(
      id = rawRcvAccession
        .extract("@Accession")
        .getOrElse {
          throw new IllegalStateException(s"Found an RCV with no ID: $rawRcvAccession")
        }
        .str,
      version = rawRcvAccession
        .extract("@Version")
        .getOrElse {
          throw new IllegalStateException(
            s"Found an RCV with no version: $rawRcvAccession"
          )
        }
        .str
        .toLong,
      variationId = variation.id,
      vcvId = vcv.id,
      title = rawRcvAccession.extract("@Title").map(_.str),
      dateLastEvaluated = rawRcvAccession.extract("@DateLastEvaluated").map(_.str),
      reviewStatus = rawRcvAccession.extract("@ReviewStatus").map(_.str),
      interpretation = rawRcvAccession.extract("@Interpretation").map(_.str),
      submissionCount = rawRcvAccession.extract("@SubmissionCount").map(_.str.toLong),
      independentObservations =
        rawRcvAccession.extract("@independentObservations").map(_.str.toLong),
      traitSetId = relevantTraitSetId
    )
  }
}
